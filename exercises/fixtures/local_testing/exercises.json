[
  {
    "model": "exercises.exercise",
    "pk": 1,
    "fields": {
      "title": "Suma",
      "statement": "Crea una función que reciba dos números (parámetros) y devuelva la suma de ambos.\nLa función debe llamarse `suma()`.",
      "function_name": "suma",
      "test": "import unittest\n\nclass TestSuma(unittest.TestCase):\n    def test_esta_definida(self):\n        self.assertIn('foo', globals(), \"La función no está definida\")\n\n    def test_es_una_funcion(self):\n        self.assertTrue(callable(foo), \"No es una función callable\")\n        self.assertEqual(type(foo), type(lambda x: x), \"No es una función\")\n\n    def test_parametros(self):\n        try:\n            self.assertEqual(foo.__code__.co_argcount, 2,\n                             \"La función suma debe recibir dos parámetros\")\n        except AttributeError:\n            self.fail(\"La función no tiene la estructura correcta\")\n\n    def test_suma_enteros(self):\n        try:\n            resultado = foo(1, 2)\n        except TypeError:\n            self.fail(\"La función no acepta enteros como parámetros\")\n\n        self.assertIsInstance(resultado, int,\n                              \"El resultado debe ser un entero\")\n        self.assertEqual(resultado, 3,\n                         \"La suma de 1 y 2 debe ser 3\")\n\n    def test_suma_negativos(self):\n        try:\n            resultado = foo(-1, -2)\n        except TypeError:\n            self.fail(\"La función no acepta enteros negativos como parámetros\")\n\n        self.assertIsInstance(resultado, int,\n                              \"El resultado debe ser un entero\")\n        self.assertEqual(resultado, -3,\n                         \"La suma de -1 y -2 debe ser -3\")\n\n    def test_suma_floats(self):\n        try:\n            resultado = foo(1.5, 2.5)\n        except TypeError:\n            self.fail(\"La función no acepta flotantes como parámetros\")\n\n        self.assertIsInstance(resultado, float,\n                              \"El resultado debe ser un float\")\n        self.assertEqual(resultado, 4.0,\n                         \"La suma de 1.5 y 2.5 debe ser 4.0\")\n\n    def test_retorna_valor(self):\n        try:\n            resultado = foo(1, 2)\n        except TypeError:\n            self.fail(\"Error al ejecutar la función\")\n\n        self.assertIsNotNone(resultado,\n                             \"La función no retorna un valor\")\n\n\nif __name__ == '__main__':\n    unittest.main()\n",
      "solution": "def suma(a, b):\n    return a + b",

      "unit": 1
    }
  },
  {
    "model": "exercises.exercise",
    "pk": 2,
    "fields": {
      "title": "Calculadora",
      "statement": "Crea una función que reciba dos números y un simbolo que represente la operacion a realizar (3 parámetros en total) y devuelva el resultado de aplicar la operacion entre ambos.\nLa función debe llamarse `calculadora()`.",
      "function_name": "calculadora",
      "test": "import unittest\n\nclass Test(unittest.TestCase):\n    \"\"\"\n    Test para la funcion foo\n    \"\"\"\n\n    \"\"\" ===== TEST COMUNES ===== \"\"\"\n    def test_esta_definida(self):\n        self.assertIn('foo', globals(), \"La función no está definida\")\n\n    def test_es_una_funcion(self):\n        self.assertTrue(callable(foo), \"No es una función callable\")\n        self.assertEqual(type(foo), type(lambda x: x), \"No es una función\")\n\n    def test_parametros(self):\n        cantidad = 3\n        try:\n            self.assertEqual(foo.__code__.co_argcount, cantidad,\n                             f\"La función suma debe recibir {cantidad} parámetros\")\n        except AttributeError:\n            self.fail(\"La función no tiene la estructura correcta\")\n\n    def test_retorna_valor(self):\n        try:\n            resultado = foo(1, 2, '+')\n        except TypeError:\n            self.fail(\"Error al ejecutar la función\")\n\n        self.assertIsNotNone(resultado,\n                             \"La función no retorna un valor\")\n\n    \"\"\" ===== TEST ESPECIFICOS ===== \"\"\"\n\n    def test_suma(self):\n        try:\n            resultado = foo(1, 2, '+')\n        except TypeError:\n            self.fail(\"La función no acepta enteros como parámetros\")\n\n        self.assertIsInstance(resultado, int,\n                              \"El resultado debe ser un entero\")\n        self.assertEqual(resultado, 3,\n                         \"La suma de 1 y 2 debe ser 3\")\n\n    def test_suma_negativos(self):\n        try:\n            resultado = foo(-1, -2, '+')\n        except TypeError:\n            self.fail(\"La función no acepta enteros negativos como parámetros\")\n\n        self.assertIsInstance(resultado, int,\n                              \"El resultado debe ser un entero\")\n        self.assertEqual(resultado, -3,\n                         \"La suma de -1 y -2 debe ser -3\")\n\n    def test_suma_floats(self):\n        try:\n            resultado = foo(1.5, 2.5, '+')\n        except TypeError:\n            self.fail(\"La función no acepta flotantes como parámetros\")\n\n        self.assertIsInstance(resultado, float,\n                              \"El resultado debe ser un float\")\n        self.assertEqual(resultado, 4.0,\n                         \"La suma de 1.5 y 2.5 debe ser 4.0\")\n\n    def test_resta(self):\n        try:\n            resultado = foo(5, 3, '-')\n        except TypeError:\n            self.fail(\"La función no acepta enteros como parámetros\")\n\n        self.assertIsInstance(resultado, int,\n                              \"El resultado debe ser un entero\")\n        self.assertEqual(resultado, 2,\n                         \"La resta de 5 y 3 debe ser 2\")\n\n    def test_multiplicacion(self):\n        try:\n            resultado = foo(2, 3, '*')\n        except TypeError:\n            self.fail(\"La función no acepta enteros como parámetros\")\n\n        self.assertIsInstance(resultado, int,\n                              \"El resultado debe ser un entero\")\n        self.assertEqual(resultado, 6,\n                         \"La multiplicación de 2 y 3 debe ser 6\")\n\n    def test_division(self):\n        try:\n            resultado = foo(6, 3, '/')\n        except TypeError:\n            self.fail(\"La función no acepta enteros como parámetros\")\n\n        self.assertIsInstance(resultado, float,\n                              \"El resultado debe ser un float\")\n        self.assertEqual(resultado, 2.0,\n                         \"La división de 6 y 3 debe ser 2.0\")\n\n\n\nif __name__ == '__main__':\n    unittest.main()\n",

      "unit": 1
    }
  }
]
